---
title: "Initial GIS procesing"
---
 

```{r, include = FALSE}
knitr::opts_chunk$set(
                    collapse = TRUE,
                    comment = "#>"
                  )

```

## Aim

To explore and pre-process the GIS data for the example catchment.

## Installing required R packages

R has multiple packages for the processing and analysis spatial data. A good
overview is given in the [Spatial Task View on
CRAN](https://cran.r-project.org/web/views/Spatial.html).
For this
part of the training course we use a set of mature packages, rgoes, rgdal, and
raster. Similar results could be obtained using either of the terra or sf
packages.

To install the packages enter at the R command prompt
```{r install_gis, eval=FALSE}
install.packages(c("rgeos","rgdal","raster","sp"))
```
Once installed the raster and sp packages are attached to the R environment so that there
functions are available.
```{r attach_gis}
library(raster)
library(sp)
```

## Digital Elevation Model

The basis of the landscape discretisation is the DEM of the catchment. Start
by loading and plottign the DEM dta and the catchment outline in the example
data. To do this we will use the `raster` package which allows the
manipulation of raster (and some vector) GIS data in R.

```{r, plot_dem}
dem <- raster(file.path(".","eden_data","unprocessed","dem.tif")) # load the dem as a raster layer
eden <- shapefile(file.path(".","eden_data","unprocessed","76007")) # load the outline of the catchment from the shapefile

## plot the dem and outline
plot(dem)
plot(eden,add=TRUE)
```

In the above plot we can see that the DEM extends beyond the boundary of the
catchment. The processing in `dynatopGIS` treats all the finite DEM values as
being within the catchment. This means we need to trim teh DEM to the
catchment boundaries.

To acheive this we will first rasterise the catchment boundary

```{r, raster_boundary}
edenRaster <- rasterize(eden, dem, field=1)
plot(edenRaster)
plot(eden,add=TRUE)
```
then mask the DEM to set all values outside the catchment to `NA`
```{r, mask_dem}
edenDEM <- mask(dem,edenRaster)
plot(edenDEM)
plot(eden,add=TRUE)
```

The raster fields created (`edenRaster`, `edenDEM`) exist only in memory (or
tempory files). Since `edenDEM` will be needed later we will save it:

```{r, save_eden_dem}
writeRaster(edenDEM,file.path(".","eden_data","processed","edenDEM.tif"),overwrite=TRUE)
```

To those of familiar with the raster package might have noticed that `edenDEM` could have created in one line by
```{r, mask_dem_2,eval=FALSE}
edenDEM <- rasterize(eden, dem, mask=TRUE)
```

## Channel Network

<!-- Processing of the channel network is motivated by matching the requirements of the -->
<!-- channel routing algorithm used in the later simulations.  -->


<!-- chn <- shapefile(file.path(raw_path,"EdenRiverNetwork")) -->

<!-- csvGauges <- read.csv(file.path(raw_path,"Q_station_location.csv")) -->
<!-- gauges <- SpatialPointsDataFrame(coords=csvGauges[,c("x","y")],proj4string=crs(chn),data=csvGauges) -->

<!-- plot(chn) -->
<!-- plot(gauges,add=TRUE,col="red",pch=21) -->
<!-- plot(eden,add=TRUE) -->

<!-- trim to the catchment -->

<!-- gauges <- intersect(gauges,eden) -->

<!-- work out nearest line -->
<!-- ```{r, nearest_channel} -->
<!-- gauges$chn_identifier <- character(nrow(gauges)) -->
<!-- gauges$chn_distance <- numeric(nrow(gauges)) -->


<!-- plot(chn) -->
<!-- plot(gauges,add=TRUE,col="red",pch=21) -->
<!-- plot(end_pts,add=TRUE,col="red",pch=21) -->
<!-- plot(eden,add=TRUE) -->

<!-- trim to the catchment -->

<!-- gauges <- intersect(gauges,eden) -->

<!-- work out nearest line -->
<!-- ```{r, nearest_channel} -->
<!-- gauges$chn_identifier <- character(nrow(gauges)) -->
<!-- gauges$chn_distance <- numeric(nrow(gauges)) -->

<!-- tmp <- geom(chn) -->
<!-- pts <- do.call("rbind",by(tmp,tmp[,"object"],function(x){x[nrow(x),]})) -->
<!-- pts <- SpatialPointsDataFrame( -->

<!-- ## For each point, find name of nearest polygon (in this case, Belgian cantons) -->


<!-- ## For each point, find name of nearest polygon (in this case, Belgian cantons) -->
<!-- for(ii in 1:nrow(gauges)){ -->
<!--   tmp <- rgeos::gDistance(gauges[ii,], chn, byid=TRUE) -->
<!--   jj <- which.min(tmp) -->
<!--   gauges$chn_identifier[ii] <- chn$identifier[jj] -->
<!--   gauges$chn_distance[ii] <- tmp[jj] -->
<!-- } -->
<!-- ``` -->
<!-- tmp <- chn[chn$identifier %in% gauges$chn_identifier,] -->
<!-- length(unique(gauges$chn_identifier)) -->
<!-- plot(chn) -->
<!-- plot(gauges,add=TRUE,pch=21,col="red") -->
<!-- plot(tmp,add=TRUE,col="orange") -->

<!-- tmp <- geom(chn) -->
<!-- end_pts <- do.call("rbind",by(tmp,tmp[,"object"],function(x){x[nrow(x),]})) -->
<!-- end_pts <- SpatialPointsDataFrame(coords=end_pts[,c("x","y")],proj4string=crs(gauges),data=end_pts) -->


<!-- is processed to match the req -->
<!-- Adding river channel data is more complex. The `add_channel` method requires a -->
<!-- `SpatialLinesDataFrame` or `SpatialPolygonsDataFrame` as generated by the `sp` -->
<!-- package. Each entry in the data.frame is treated as a length of river channel -->
<!-- which requires the following properties -->

<!-- -   *endNode* - a label for the downstream end of the river length -->
<!-- -   *startNode* - a label for the upstream end of the river length -->
<!-- -   *length* - the length in meters -->

<!-- Additional properties are currently kept but ignored with two exceptions: -->
<!-- -   *id* - this is copied to `original_id` with a warning since `id` is used internally -->
<!-- -   *width* - if the channel is specified with a line sections then the *width* -->
<!--     property is used to buffer the lines to create channel polygons. -->
